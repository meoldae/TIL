## HTTP/3
HTTP/2.0까지도 TCP 프로토콜에서 동작하기 때문에 `HOLB`문제를 완전히 해소할 수 없었다. TCP 특성상 중간에 데이터가 손실되었을 때 재전송을 수행한다. 그리고 데이터를 순서대로 처리해야 하므로 재전송하는 과정에서 지연이 발생했다.

또한 TCP는 송-수신측의 데이터 처리 속도 차이를 제어하는 `혼잡제어`를 수행하는데, 느린 전송속도부터 천천히 높여가는 방식으로 동작한다.    
이는 네트워크 상황이 원활할 때도 불필요한 지연이 발생한다.

이런 근본적인 문제의 해결을 위해 HTTP/3은 구글이 자체 개발한 `UDP` 기반의 `QUIC` 프로토콜에서 동작한다.   
UDP 기반 프로토콜은 기본적인 신뢰성을 보장하지 않는다. 이런 신뢰성, 혼잡 제어 기능들을 직접 구현해 추가한 것이 `QUIC`인 것이다.

### HandShake
HTTP/3에서는 이전의 연결 정보를 캐싱하여 재사용하는 0-RTT, 1-RTT를 제공한다. 핸드셰이크 과정을 크게 줄여 지연시간을 줄일 수 있었다.   
핸드셰이크 과정이 별 것 아닌 것 같지만, 서버와 클라이언트가 서로 지구 반대편에 있고 빛이 지구 반대편에 도달하고 다시 돌아오는데 걸리는 시간은 약 130ms다. 왕복이므로 매 연결마다 약 270ms가 소모되는데 이를 줄일 수 있는 것이다.

링크 : [1-RTT, 0-RTT](https://luavis.me/server/tls-1.3)
<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/236083401-684c9973-c5fe-4742-8678-8b3beac2759d.png">
</div>

### 다중화 Multiflexing
HTTP/3은 연결 다중화를 완전하게 지원하며, 각각의 스트림이 `독립적`으로 동작한다.

<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/236089968-acb9acb8-383f-417e-b9e0-bdd720fceaa4.png">
</div>

HTTP/2.0에서 여러 스트림을 동시에 사용할 수 있으나 TCP 프로토콜이므로 데이터 손실이 발생했을 때 재전송하며 지연이 발생한다.    
HTTP/3에서는 스트림이 완전하게 독립적이므로 데이터 손실이 발생해도 다른 스트림에 영향을 주지 않는다.

또한 HTTP/3은 IP 기반이 아닌 연결마다 고유한 UUID를 사용하여 연결을 식별한다. 덕분에 WI-FI에서 셀룰러 환경으로 이동해도, 그 반대의 경우에도 재 연결 과정이 필요없어진다.

HTTP/3 역시 `HPACK`과 유사하게 `QPACK`을 이용해 헤더압축이 이루어진다. 스트림이 독립적으로 동작하므로 그에 맞춰 개선된 방안이다.

### 참고자료
---
[요즘IT : 웹 개발자라면 알고 있어야 할 HTTP의 진화 과정](https://yozm.wishket.com/magazine/detail/1686/)