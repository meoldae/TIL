# Bean Validation

필드에 대한 검증 로직을 어노테이션 하나로 편리하게 적용할 수 있다.

> Bean Validation은 구현체가 아니라 JPA 처럼 기술 표준으로 인터페이스의 모음이다. 일반적으로 구현체는 하이버네이트 Validator를 사용한다. ❗ JPA 구현체와 관련 없다!!

- 예제 코드
    ```java
    public class Item {

        private Long id;

        @NotBlank
        private String itemName;

        @NotNull
        @Range(min = 1000, max = 100000)
        private Integer price;

        @NotNull
        @Max(9999)
        private Integer quantity;
    }
    ```
    - 코드 블럭처럼 여러 어노테이션을 활용해 검증 로직을 수행할 수 있다!<br>
    [다른 애노테이션 더 보기..](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec)

### 검증 ?

```java
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
```
위 코드와 같은 형태로 검증기를 직접 생성하여 사용할 수도 있다. 그러나 Spring 통합시 이런 코드를 작성할 필요 없다!

- 예제 코드
    ```java
    @PostMapping("/add")
    public String addItem(@Validated @ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes) {
        if (bindingResult.hasErrors()) {
            log.info("errors={}", bindingResult);
            return "validation/v3/addForm";
        }
        ... 
    }

    ```
    - `@ModelAttribute`의 앞에 `@Validated` 혹은 `@Valid` 를 붙임으로써 검증기가 작동한다.
        - `@Validated` : 스프링 전용 검증
        - `@Valid` : 자바 표준 검증
    - 바인딩에 성공한 필드에 대해서만 검증이 적용된다. 바인딩 실패시 `typeMismatch` 에러가 생성되고, `bindingResult` 에 담기게 된다.
- 에러 코드
    - Bean Validation이 적용된 후 오류가 발생하면 해당 어노테이션 이름으로 오류코드가 등록된다.

        > @NotBlank
        > - NotBlank.item.itemName
        > - NotBlank.itemName
        > - NotBlank.java.lang.String
        > - NotBlank

- `Object Error`
    - Object Error 검증은 `@ScriptAssert()`를 사용할 수 있다.
    - 예제 코드
        ```java
            @ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity >= 10000")
            public class Item {
                //...
            }
        ```