# JPQL - 심화

### 경로 표현식
```.(점)```을 통해 객체를 그래프 탐색하는 것
- 상태필드 
    - 단순한 값 저장을 위한 필드
    - 더 이상 탐색이 불가
- 연관 필드 : 연관관계를 위한 필드
    - 단일 값
        - 대상이 엔티티
        - INNER JOIN 발생하며 재 탐색 가능
    - 컬렉션 값
        - 대상이 컬렉션 값
        - INNER JOIN이 발생하지만 재 탐색 불가능
        - 명시적 JOIN을 통해 얻으면 ```.```으로 탐색 가능
- 묵시적 JOIN 사용 지양, 실무에서는 명시적 JOIN 쓰자!!

### ★ FETCH JOIN 페치 조인
JPQL에서 성능 최적화를 위한 기능으로 연관관계에 있는 엔티티, 컬렉션을 SQL 한번으로 조회하는 기능
- ```JOIN FETCH``` 라는 구문을 통해 사용
- 첫 조회순간에 프록시 객체가 아니라 실제 엔티티가 담김
- 컬렉션 페치 조인
    - 일대다(컬렉션)의 경우 페치조인시 중복이 발생
        - JPQL의 DISTINCT 사용하면?
            - SQL에서 DISTINCT를 통해 제거
            - 애플리케이션 레벨에서 엔티티 중복을 제거 

- 페치 조인의 한계
    - 대상에 별칭 불가
    - 둘 이상의 컬렉션은 페치조인 불가
    - 컬렉션 페치 조인시 페이징 API 사용 불가
        - 단일값 연관필드는 가능

- 특징
    - 엔티티에 직접 어노테이션으로 적용하는 것보다 우선
    - 기본적으로 모두 지연로딩하되, 최적화가 꼭 필요한 곳만 페치조인 적용

### 다형성 쿼리
- 조회 대상을 특정 대상으로 한정할 수 있다. -> ```SELECT i FROM Item i WHERE TYPE(i) in (Book, Movie) ```
- TREAT : 형변환과 비슷 -> ```SELECT i FROM Item i WHERE TREAT(i AS Book).author = 'kim'```

### @NamedQuery
- 엔티티에 미리 정의해두고 재사용하는 JPQL
- 정적인 쿼리로 나중에 추가할 수 없음;
- 애플리케이션 로딩시점에 초기화 후 재사용 
    - 로딩시점에 파싱해놓고 캐시해둠
    - 로딩시점에 쿼리 검증 가능

### 벌크 연산
하나의 행을 골라서 Update, Delete 하는것이 아닌 모든 Update, Delete 연산을 벌크연산이라고 칭함
- 쿼리 한번으로 여러 테이블의 행을 변경
- ```executeUpdate()```의 결과는 영향받은 엔티티 수 반환 => JDBC랑 비슷
- 영속성 컨텍스트를 무시하고 데이터베이스를 직접 쿼리
    - 1. 벌크연산을 먼저 수행하거나,
    - 2. 벌크연산 수행 후 영속성 컨텍스트 초기화
